----------------------------------------------------------------------------------------------------

虚函数多态
https://blog.csdn.net/zhendong825/article/details/134219456

----------------------------------------------------------------------------------------------------

当使用基类指针创建并操作派生类对象时，依然遵循以下顺序：

构造顺序
基类构造函数。
派生类的成员变量构造函数。
派生类构造函数。

析构顺序
派生类析构函数。
派生类的成员变量析构函数。
基类析构函数。
只要对象被创建，这些步骤就会自动按此顺序发生，不管您是使用派生类类型还是基类类型来引用它。
唯一需要注意的是，如果您打算通过基类指针来删除派生类对象（即使用delete），您必须确保基类的析构函数是虚拟的（virtual）。
否则，在使用基类指针删除派生类对象时，可能不会调用派生类的析构函数，从而导致资源泄露或其他问题。


----------------------------------------------------------------------------------------------------



`new/delete` 和 `malloc/free` 是 C++ 和 C 语言中用于动态内存分配和释放的不同机制。它们的主要区别如下：

### new/delete（C++）
- **构造和析构**：`new` 在分配内存后会调用对象的构造函数，初始化对象。`delete` 在释放对象内存前会调用对象的析构函数，进行清理工作。
- **类型安全**：`new` 是类型安全的，它知道它所分配内存的确切类型，并返回正确的指针类型，无需类型转换。例如：`int* p = new int;`
- **异常处理**：如果内存分配失败，`new` 抛出一个 `std::bad_alloc` 异常，除非使用了 `nothrow` 版本。例如：`int* p = new (std::nothrow) int;`
- **操作符重载**：可以重载 `new` 和 `delete` 操作符来改变其行为。

```cpp
int* p = new int(5);   // 分配内存并初始化为 5
delete p;              // 释放内存
```

### malloc/free（C/C++）
- **仅内存分配和释放**：`malloc` 只负责分配所需大小的内存块，不调用构造函数；`free` 只负责释放内存，不调用析构函数。
- **无类型安全**：`malloc` 返回 `void*` 类型的指针，需要强制转换为对应类型的指针。例如：`int* p = (int*)malloc(sizeof(int));`
- **错误处理**：如果内存分配失败，`malloc` 返回 `NULL` 指针，需要手动检查。
- **不能被重载**：`malloc` 和 `free` 是库函数，不可以被重载。

```c
int* p = (int*)malloc(sizeof(int)); // 分配内存
if (p != NULL) {
    *p = 5;                         // 初始化内存
}
free(p);                             // 释放内存
```

### 其他区别
- **内存对齐**：`new` 通常保证按照类型的对齐要求分配内存。而 `malloc` 是按字节分配的，但它也保证足够的对齐以适合任何内置类型。
- **数组处理**：`new[]` 和 `delete[]` 用于数组类型的分配和释放，能自动处理数组中每个对象的构造和析构。`malloc` 和 `free` 无法做到这一点。

在 C++ 中推荐使用 `new/delete` 而不是 `malloc/free`，因为它们支持构造和析构，更符合 C++ 的面向对象特性，且提供了类型安全和异常处理机制。当然，在涉及 C++ 和 C 代码混合编程时，可能需要根据具体情况选用适当的内存管理方法。


----------------------------------------------------------------------------------------------------

Lambda 表达式本质上是在其定义的作用域中捕获变量。它们不能直接跨越到与定义它们不同的作用域去捕获变量。当你定义一个 lambda 表达式时，
它可以捕获以下几种类型的作用域变量：

1. 当前作用域（父作用域）内的局部变量。
2. 以值传递的方式捕获的成员变量的副本（如果 lambda 在类的成员函数中定义）。
3. 如果使用 `[&]` 或具体名称进行引用捕获，则为对这些变量的引用。

但是，lambda 无法访问除定义它的作用域以外的其他局部作用域中的变量。然而，你可以通过几种方式来间接实现相似的效果：

### 捕获指针或引用

你可以在定义 lambda 的作用域内创建指向另一个作用域中变量的指针或引用，并捕获这些指针或引用。

```cpp
void outerScope() {
    int x = 10; // 定义于外层作用域的变量
    auto lambda = [&x]() { /* 可以访问 x */ };
    lambda(); // 此处有效，因为 x 在作用域内
}

void anotherFunction() {
    // 这里无法定义一个直接访问 outerScope 中 x 的 lambda
}
```

### 使用 std::function

如果你想要在一个不同的作用域能够使用某个作用域内的变量，你可以考虑将 lambda 赋给 `std::function` 并将其传递到其他作用域中。

```cpp
#include <functional>

void anotherFunction(std::function<void()> func) {
    // 在这里调用 func 将能够访问它在另一个作用域中捕获的变量
    func();
}

void outerScope() {
    int x = 10;
    auto lambda = [x]() { /* 可以访问 x */ };
    anotherFunction(lambda);
}
```

### 静态或全局变量

静态存储期的变量（如静态局部变量、全局变量、静态成员变量）对所有函数和作用域都是可见的，因此可以在任何地方被访问，包括 lambda 表达式中，
而不需要显式捕获。

```cpp
int globalVar = 5;

void someFunction() {
    auto lambda = []() { return globalVar; };
    // 可以访问全局变量 globalVar
}
```

正如前面提到的，尽管有这些方法可以绕过直接跨作用域捕获变量的限制，但需要特别注意资源管理和生命周期问题，以防止悬空引用和其它相关的错误。
如果你捕获了一个指针或引用，并且原始对象已经超出了其生命周期，那么试图通过 lambda 访问它将导致未定义行为。


----------------------------------------------------------------------------------------------------
