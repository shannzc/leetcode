----------------------------------------------------------------------------------------------------

虚函数多态
https://blog.csdn.net/zhendong825/article/details/134219456

----------------------------------------------------------------------------------------------------

当使用基类指针创建并操作派生类对象时，依然遵循以下顺序：

构造顺序
基类构造函数。
派生类的成员变量构造函数。
派生类构造函数。

析构顺序
派生类析构函数。
派生类的成员变量析构函数。
基类析构函数。
只要对象被创建，这些步骤就会自动按此顺序发生，不管您是使用派生类类型还是基类类型来引用它。
唯一需要注意的是，如果您打算通过基类指针来删除派生类对象（即使用delete），您必须确保基类的析构函数是虚拟的（virtual）。
否则，在使用基类指针删除派生类对象时，可能不会调用派生类的析构函数，从而导致资源泄露或其他问题。


----------------------------------------------------------------------------------------------------



`new/delete` 和 `malloc/free` 是 C++ 和 C 语言中用于动态内存分配和释放的不同机制。它们的主要区别如下：

### new/delete（C++）
- **构造和析构**：`new` 在分配内存后会调用对象的构造函数，初始化对象。`delete` 在释放对象内存前会调用对象的析构函数，进行清理工作。
- **类型安全**：`new` 是类型安全的，它知道它所分配内存的确切类型，并返回正确的指针类型，无需类型转换。例如：`int* p = new int;`
- **异常处理**：如果内存分配失败，`new` 抛出一个 `std::bad_alloc` 异常，除非使用了 `nothrow` 版本。例如：`int* p = new (std::nothrow) int;`
- **操作符重载**：可以重载 `new` 和 `delete` 操作符来改变其行为。

```cpp
int* p = new int(5);   // 分配内存并初始化为 5
delete p;              // 释放内存
```

### malloc/free（C/C++）
- **仅内存分配和释放**：`malloc` 只负责分配所需大小的内存块，不调用构造函数；`free` 只负责释放内存，不调用析构函数。
- **无类型安全**：`malloc` 返回 `void*` 类型的指针，需要强制转换为对应类型的指针。例如：`int* p = (int*)malloc(sizeof(int));`
- **错误处理**：如果内存分配失败，`malloc` 返回 `NULL` 指针，需要手动检查。
- **不能被重载**：`malloc` 和 `free` 是库函数，不可以被重载。

```c
int* p = (int*)malloc(sizeof(int)); // 分配内存
if (p != NULL) {
    *p = 5;                         // 初始化内存
}
free(p);                             // 释放内存
```

### 其他区别
- **内存对齐**：`new` 通常保证按照类型的对齐要求分配内存。而 `malloc` 是按字节分配的，但它也保证足够的对齐以适合任何内置类型。
- **数组处理**：`new[]` 和 `delete[]` 用于数组类型的分配和释放，能自动处理数组中每个对象的构造和析构。`malloc` 和 `free` 无法做到这一点。

在 C++ 中推荐使用 `new/delete` 而不是 `malloc/free`，因为它们支持构造和析构，更符合 C++ 的面向对象特性，且提供了类型安全和异常处理机制。当然，在涉及 C++ 和 C 代码混合编程时，可能需要根据具体情况选用适当的内存管理方法。


----------------------------------------------------------------------------------------------------

Lambda 表达式本质上是在其定义的作用域中捕获变量。它们不能直接跨越到与定义它们不同的作用域去捕获变量。当你定义一个 lambda 表达式时，
它可以捕获以下几种类型的作用域变量：

1. 当前作用域（父作用域）内的局部变量。
2. 以值传递的方式捕获的成员变量的副本（如果 lambda 在类的成员函数中定义）。
3. 如果使用 `[&]` 或具体名称进行引用捕获，则为对这些变量的引用。

但是，lambda 无法访问除定义它的作用域以外的其他局部作用域中的变量。然而，你可以通过几种方式来间接实现相似的效果：

### 捕获指针或引用

你可以在定义 lambda 的作用域内创建指向另一个作用域中变量的指针或引用，并捕获这些指针或引用。

```cpp
void outerScope() {
    int x = 10; // 定义于外层作用域的变量
    auto lambda = [&x]() { /* 可以访问 x */ };
    lambda(); // 此处有效，因为 x 在作用域内
}

void anotherFunction() {
    // 这里无法定义一个直接访问 outerScope 中 x 的 lambda
}
```

### 使用 std::function

如果你想要在一个不同的作用域能够使用某个作用域内的变量，你可以考虑将 lambda 赋给 `std::function` 并将其传递到其他作用域中。

```cpp
#include <functional>

void anotherFunction(std::function<void()> func) {
    // 在这里调用 func 将能够访问它在另一个作用域中捕获的变量
    func();
}

void outerScope() {
    int x = 10;
    auto lambda = [x]() { /* 可以访问 x */ };
    anotherFunction(lambda);
}
```

### 静态或全局变量

静态存储期的变量（如静态局部变量、全局变量、静态成员变量）对所有函数和作用域都是可见的，因此可以在任何地方被访问，包括 lambda 表达式中，
而不需要显式捕获。

```cpp
int globalVar = 5;

void someFunction() {
    auto lambda = []() { return globalVar; };
    // 可以访问全局变量 globalVar
}
```

正如前面提到的，尽管有这些方法可以绕过直接跨作用域捕获变量的限制，但需要特别注意资源管理和生命周期问题，以防止悬空引用和其它相关的错误。
如果你捕获了一个指针或引用，并且原始对象已经超出了其生命周期，那么试图通过 lambda 访问它将导致未定义行为。


----------------------------------------------------------------------------------------------------
#智能指针
在C++中，智能指针用于自动管理动态内存，避免内存泄漏和悬空指针等问题。常见的三种智能指针包括：

std::unique_ptr:

特点: 独占所有权，同一时间只能有一个unique_ptr指向某个对象。
用途: 适用于需要明确独占资源所有权的场景。
std::unique_ptr<int> ptr(new int(10));
// ptr 独占所有权，不能复制，只能移动
std::unique_ptr<int> ptr2 = std::move(ptr);



std::shared_ptr:
特点: 共享所有权，多个shared_ptr可以指向同一个对象，使用引用计数管理资源。
用途: 适用于需要共享资源所有权的场景。
std::shared_ptr<int> ptr1(new int(10));
std::shared_ptr<int> ptr2 = ptr1; // 引用计数增加


std::weak_ptr:
特点: 弱引用，不增加引用计数，用于解决shared_ptr的循环引用问题。
用途: 适用于需要观察资源但不影响其生命周期的场景。
std::shared_ptr<int> ptr1(new int(10));
std::weak_ptr<int> weakPtr = ptr1; // 不增加引用计数
if (auto sharedPtr = weakPtr.lock()) {
    // 使用 sharedPtr
}

----------------------------------------------------------------------------------------------------------------

std::move 是 C++ 标准库中的一个工具，用于将对象的状态或资源所有权从一个对象转移到另一个对象，而无需进行深拷贝。它并不会真正“移动”数据，而是将对象标记为“可移动”，从而使编译器能够调用移动构造函数或移动赋值运算符。

核心作用
将左值转换为右值引用：std::move 的本质是将一个左值强制转换为右值引用（T&&），从而允许调用移动语义。

优化资源管理：通过移动语义，可以避免不必要的深拷贝，提高性能，尤其是在处理动态内存、文件句柄等资源时。

使用场景
移动语义：
当一个对象不再需要当前资源时，可以使用 std::move 将其资源转移到另一个对象。


std::string str1 = "Hello";
std::string str2 = std::move(str1); // str1 的资源被移动到 str2
// 此时 str1 为空（有效但未定义的状态）
容器操作：
在容器中移动元素，避免拷贝开销。


std::vector<std::string> vec1 = {"a", "b", "c"};
std::vector<std::string> vec2 = std::move(vec1); // vec1 的资源被移动到 vec2
// 此时 vec1 为空
智能指针管理：
用于转移 std::unique_ptr 的所有权。


std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
std::unique_ptr<int> ptr2 = std::move(ptr1); // ptr1 的资源被移动到 ptr2
// 此时 ptr1 为空（nullptr）
注意事项
被移动的对象状态：
被移动的对象在调用 std::move 后，其状态是“有效但未定义的”。通常应该避免继续使用它，除非重新赋值。


std::string str1 = "Hello";
std::string str2 = std::move(str1);
// str1 的状态是有效但未定义的，可能是空字符串，但不保证
不能移动常量对象：
常量对象（const）不能使用 std::move，因为移动语义会修改对象状态。

const std::string str1 = "Hello";
// std::string str2 = std::move(str1); // 错误：不能移动 const 对象
性能优化：
std::move 只有在对象支持移动语义（即定义了移动构造函数或移动赋值运算符）时才有意义。对于基本类型（如 int、double），std::move 不会有任何效果。


#include <iostream>
#include <string>
#include <vector>

int main() {
    std::string str1 = "Hello, World!";
    std::string str2 = std::move(str1); // 移动 str1 的资源到 str2

    std::cout << "str1: " << str1 << std::endl; // str1 为空
    std::cout << "str2: " << str2 << std::endl; // str2 包含 "Hello, World!"

    std::vector<int> vec1 = {1, 2, 3};
    std::vector<int> vec2 = std::move(vec1); // 移动 vec1 的资源到 vec2

    std::cout << "vec1 size: " << vec1.size() << std::endl; // vec1 为空
    std::cout << "vec2 size: " << vec2.size() << std::endl; // vec2 包含 3 个元素

    return 0;
}
总结
std::move 是 C++11 引入的重要工具，用于启用移动语义。

它通过将左值转换为右值引用来触发移动构造函数或移动赋值运算符。

使用 std::move 可以显著提高性能，尤其是在处理大型对象或资源密集型操作时。

注意被移动对象的状态，避免在移动后继续使用它。
--------------------------------------------------------------------------
push_back 和 emplace_back 的区别
特性    	push_back                      	   emplace_back
参数传递	接受一个对象（左值或右值）      	 接受构造对象所需的参数
构造方式	需要先构造对象，再拷贝或移动到容器	  直接在容器中构造对象
性能	    可能涉及拷贝或移动操作	           避免不必要的拷贝或移动，性能更优
适用场景	适用于已有对象需要添加到容器的情况	  适用于直接在容器中构造对象的情况
